{
 "cells": [
  {
   "cell_type": "markdown",
   "metadata": {
    "nbsphinx": "hidden"
   },
   "source": [
    "This notebook is part of the `kikuchipy` documentation https://kikuchipy.org.\n",
    "Links to the documentation won't work from the notebook."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# Hybrid indexing"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# Exchange inline for notebook or qt5 (from pyqt) for interactive plotting\n",
    "%matplotlib qt5\n",
    "\n",
    "from pathlib import Path\n",
    "\n",
    "import matplotlib.pyplot as plt\n",
    "import numpy as np\n",
    "\n",
    "from diffsims.crystallography import ReciprocalLatticeVector\n",
    "import hyperspy.api as hs\n",
    "import kikuchipy as kp\n",
    "from orix import sampling, plot, io\n",
    "from orix.crystal_map import PhaseList\n",
    "from orix.vector import Vector3d\n",
    "\n",
    "\n",
    "plt.rcParams.update({\"figure.facecolor\": \"w\", \"font.size\": 15})\n",
    "\n",
    "dir_data = Path(\"/home/hakon/phd/data/ni/nickel_scan_gain/scan10_gain24db\")"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Load and inspect data"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "s = kp.load(dir_data / \"Pattern.dat\")\n",
    "s"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Enhance signal-to-noise ratio (background correction)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "s.remove_static_background()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "s.remove_dynamic_background()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "window = kp.filters.Window(\"gaussian\", std=1)\n",
    "s.average_neighbour_patterns(window)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Inspect image quality map"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "iq = s.get_image_quality()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "s.plot(hs.signals.Signal2D(iq))"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Projection center calibration"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "s_cal = kp.load(dir_data / \"Setting.txt\")\n",
    "s_cal"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "s_cal.remove_static_background()\n",
    "s_cal.remove_dynamic_background()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "omd = s_cal.original_metadata"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Check pattern map locations"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "kp.draw.plot_pattern_positions_in_map(\n",
    "    rc=omd.calibration_patterns.indices_scaled,\n",
    "    roi_shape=omd.roi.shape_scaled,\n",
    "    roi_origin=omd.roi.origin_scaled,\n",
    "    roi_image=iq,\n",
    "    area_shape=omd.area.shape_scaled,\n",
    "    area_image=omd.area_image,\n",
    "    color=\"w\"\n",
    ")"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "mp = kp.data.ni_ebsd_master_pattern(\n",
    "    allow_download=True, projection=\"lambert\", energy=20\n",
    ")\n",
    "mp"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "phase = mp.phase\n",
    "\n",
    "lat = phase.structure.lattice\n",
    "lat.setLatPar(lat.a * 10, lat.b * 10, lat.c * 10)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "det_cal = s_cal.detector\n",
    "phase_list = PhaseList(phase)\n",
    "indexer = det_cal.get_indexer(phase_list)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "det_cal = s_cal.hough_indexing_optimize_pc(\n",
    "    pc0=[0.4, 0.2, 0.5],  # Initial guess based on previous experiments\n",
    "    indexer=indexer,\n",
    "    batch=True,\n",
    ")\n",
    "\n",
    "print(det_cal.pc_flattened.mean(axis=0))\n",
    "print(det_cal.pc_flattened.std(0))"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Compare distribution of PCs to map locations (especially PCx vs. PCy)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "det_cal.plot_pc(\"scatter\", annotate=True)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Index the patterns using the optimized PCs"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "indexer.PC = det_cal.pc"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "xmap_hi = s_cal.hough_indexing(phase_list=phase_list, indexer=indexer)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Check indexed orientations by plotting geometrical simulations on top of the patterns"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "rlv = ReciprocalLatticeVector.from_min_dspacing(phase)\n",
    "rlv.sanitise_phase()  # \"Fill atoms in unit cell\"\n",
    "rlv.calculate_structure_factor()\n",
    "structure_factor = abs(rlv.structure_factor)\n",
    "rlv = rlv[structure_factor > 0.5 * structure_factor.max()]\n",
    "rlv.print_table()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "simulator = kp.simulations.KikuchiPatternSimulator(rlv)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "sim_hi = simulator.on_detector(det_cal, xmap_hi.rotations)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "fig, axes = plt.subplots(ncols=3, nrows=3, figsize=(12, 12))\n",
    "for i, ax in enumerate(axes.ravel()):\n",
    "    if i <= xmap_hi.size - 1:\n",
    "        ax.imshow(s_cal.inav[i].data, cmap=\"gray\")\n",
    "        lines = sim_hi.as_collections(i, lines_kwargs=dict(color=\"w\"))[0]\n",
    "        ax.add_collection(lines)\n",
    "        ax.text(5, 10, i, c=\"w\", va=\"top\", ha=\"left\", fontsize=20)\n",
    "    ax.axis(\"off\")\n",
    "fig.subplots_adjust(wspace=0.01, hspace=0.01)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Refine indexed orientations using pattern matching"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "xmap_ref, det_ref = s_cal.refine_orientation_projection_center(\n",
    "    xmap=xmap_hi,\n",
    "    detector=det_cal,\n",
    "    master_pattern=mp,\n",
    "    energy=20,\n",
    "    method=\"LN_NELDERMEAD\",\n",
    "    trust_region=[5, 5, 5, 0.05, 0.05, 0.05],\n",
    "    rtol=1e-7,\n",
    "    # A pattern per iteration to use all CPUs\n",
    "    chunk_kwargs=dict(chunk_shape=1),\n",
    ")"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "print(xmap_ref)\n",
    "print(xmap_ref.scores.mean())"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Check refined orientations by plotting new geometrical simulations"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "sim_ref = simulator.on_detector(det_ref, xmap_ref.rotations)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "for i, ax in enumerate(axes.ravel()):\n",
    "    if i <= xmap_ref.size - 1:\n",
    "        lines = sim_ref.as_collections(i)[0]\n",
    "        ax.add_collection(lines)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Check refined PCs"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "det_ref.plot_pc(\"scatter\", annotate=True)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Fit a plane to the refined PCs using an affine transformation"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "pc_indices = omd.calibration_patterns.indices_scaled\n",
    "pc_indices -= omd.roi.origin_scaled\n",
    "pc_indices = pc_indices.T\n",
    "\n",
    "map_indices = np.indices(omd.roi.shape_scaled)\n",
    "print(\"Full map shape (n rows, n columns):\", omd.roi.shape_scaled)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "det_fit = det_ref.fit_pc(\n",
    "    pc_indices=pc_indices,\n",
    "    map_indices=map_indices,\n",
    "    transformation=\"affine\",\n",
    "    plot=False,\n",
    ")\n",
    "\n",
    "print(det_fit.pc_average)\n",
    "print(det_fit.sample_tilt)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Check the plane of PCs"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "det_fit.plot_pc()"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Finally, refine orientations only by using the fitted PCs"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "det_fit_cal = det_fit.deepcopy()\n",
    "det_fit_cal.pc = det_fit_cal.pc[tuple(pc_indices)]"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "signal_mask = ~kp.filters.Window(\"circular\", det_cal.shape).astype(bool)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "xmap_cal = s_cal.refine_orientation(\n",
    "    xmap=xmap_ref,\n",
    "    detector=det_fit_cal,\n",
    "    master_pattern=mp,\n",
    "    energy=20,\n",
    "    signal_mask=signal_mask,\n",
    "    method=\"LN_NELDERMEAD\",\n",
    "    trust_region=[5, 5, 5],\n",
    "    rtol=1e-7,\n",
    "    # A pattern per iteration to use all CPUs\n",
    "    chunk_kwargs=dict(chunk_shape=1),\n",
    ")"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "print(xmap_cal)\n",
    "print(xmap_cal.scores.mean())"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Check refined (refined) orientations by plotting, yet again, new geometrical simulations"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "sim_cal = simulator.on_detector(det_fit_cal, xmap_cal.rotations)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "for i, ax in enumerate(axes.ravel()):\n",
    "    if i <= xmap_cal.size - 1:\n",
    "        lines = sim_cal.as_collections(i, lines_kwargs=dict(color=\"b\"))[0]\n",
    "        ax.add_collection(lines)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Initial Hough indexing"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "det = det_fit.deepcopy()\n",
    "det.shape = s.detector.shape\n",
    "det"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "indexer = det.get_indexer(phase_list)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "xmap_hi = s.hough_indexing(phase_list=phase_list, indexer=indexer)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "aspect_ratio = xmap_hi.shape[1] / xmap_hi.shape[0]\n",
    "figsize = (8 * aspect_ratio, 4.5 * aspect_ratio)\n",
    "\n",
    "fig, ax = plt.subplots(nrows=2, ncols=2, figsize=figsize)\n",
    "for a, to_plot in zip(ax.ravel(), [\"pq\", \"cm\", \"fit\", \"nmatch\"]):\n",
    "    im = a.imshow(xmap_hi.get_map_data(to_plot))\n",
    "    fig.colorbar(im, ax=a, label=to_plot)\n",
    "    a.axis(\"off\")\n",
    "fig.subplots_adjust(wspace=0, hspace=0.05)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "v_ipf = Vector3d.xvector()\n",
    "sym = xmap_hi.phases[0].point_group\n",
    "\n",
    "ckey = plot.IPFColorKeyTSL(sym, v_ipf)\n",
    "ckey"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "rgb_x = ckey.orientation2color(xmap_hi[\"indexed\"].rotations)\n",
    "fig = xmap_hi[\"indexed\"].plot(rgb_x, remove_padding=True, return_figure=True)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "fig, ax = plt.subplots(ncols=2, nrows=2)\n",
    "for a, to_plot in zip(ax.ravel(), [\"pq\", \"cm\", \"fit\", \"nmatch\"]):\n",
    "    _ = a.hist(xmap_hi[\"indexed\"].prop[to_plot], bins=100)\n",
    "    a.set(xlabel=to_plot, ylabel=\"Frequency\")\n",
    "fig.tight_layout()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "mask = np.logical_or(xmap_hi[\"indexed\"].cm < 0.4, xmap_hi[\"indexed\"].fit > 1.5)\n",
    "\n",
    "xmap_hi[\"indexed\"][mask].plot(rgb_x[mask], remove_padding=True)\n",
    "xmap_hi[\"indexed\"][~mask].plot(rgb_x[~mask], remove_padding=True)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "nav_mask = np.zeros(xmap_hi.size, dtype=bool)\n",
    "nav_mask[xmap_hi.phase_id == 0] = ~mask\n",
    "nav_mask = nav_mask.reshape(xmap_hi.shape)\n",
    "\n",
    "xmap_hi.plot(nav_mask.ravel(), remove_padding=True)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Dictionary indexing of bad points"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "s2 = s.deepcopy()\n",
    "s2.downsample(2)\n",
    "s2"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "det_binned = det.deepcopy()\n",
    "det_binned.shape = (30, 30)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "signal_mask_binned = ~kp.filters.Window(\"circular\", det_binned.shape).astype(bool)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "rot = sampling.get_sample_fundamental(resolution=2, point_group=phase.point_group)\n",
    "rot"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "det_binned_pc1 = det_binned.deepcopy()\n",
    "det_binned_pc1.pc = det_binned_pc1.pc_average"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "sim = mp.get_patterns(\n",
    "    rotations=rot,\n",
    "    detector=det_binned_pc1,\n",
    "    energy=20,\n",
    "    dtype_out=np.float32,\n",
    "    chunk_shape=rot.size // 25,\n",
    ")\n",
    "sim"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "xmap_di = s2.dictionary_indexing(\n",
    "    sim,\n",
    "    keep_n=1,\n",
    "    signal_mask=signal_mask_binned,\n",
    "    navigation_mask=nav_mask,\n",
    ")"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "xmap_di.scores.mean()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "xmap_di.plot(\"scores\", remove_padding=True)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "rgb_x = ckey.orientation2color(xmap_di.rotations)\n",
    "fig = xmap_di.plot(rgb_x, remove_padding=True, return_figure=True)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "fig, ax = plt.subplots()\n",
    "_ = ax.hist(xmap_di.scores, bins=100)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "xmap_di[xmap_di.scores < 0.2].plot(\"x\", remove_padding=True)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Refinement of all points"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "signal_mask60x60 = ~kp.filters.Window(\"circular\", shape=det.shape).astype(bool)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "xmap_hi_ref = s.refine_orientation(\n",
    "    xmap=xmap_hi[\"ni\"],\n",
    "    detector=det,\n",
    "    master_pattern=mp,\n",
    "    energy=20,\n",
    "    signal_mask=signal_mask60x60,\n",
    "    method=\"LN_NELDERMEAD\",\n",
    "    trust_region=[5, 5, 5],\n",
    "    rtol=1e-3,\n",
    ")"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "xmap_hi_ref = "
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Merge results"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Validate results"
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3 (ipykernel)",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.10.8"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 4
}
